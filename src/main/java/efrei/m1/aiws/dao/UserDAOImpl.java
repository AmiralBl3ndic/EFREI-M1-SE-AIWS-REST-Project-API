package efrei.m1.aiws.dao;

import efrei.m1.aiws.model.User;
import efrei.m1.aiws.service.AuthenticationService;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.NonNull;

import java.sql.*;
import java.util.logging.Level;
import java.util.logging.Logger;

@NoArgsConstructor @AllArgsConstructor
public class UserDAOImpl implements DAO<User> {

	private static Logger logger = Logger.getLogger(UserDAOImpl.class.getName());

	//SQL column names
	static final String DB_COL_ID="ID_USER";
	static final String DB_COL_EMAIL="EMAIL";
	static final String DB_COL_PASSWORD="PASSWORD";
	static final String DB_COL_CITY="CITY";

	//Queries
	private static final String SQL_SELECT_BY_ID="SELECT ID_USER, EMAIL, PASSWORD, CITY FROM USERS WHERE ID_USER=?";
	private static final String SQL_SELECT_BY_EMAIL="SELECT ID_USER, EMAIL, PASSWORD, CITY FROM USERS WHERE EMAIL=?";
	private static final String SQL_INSERT_USER="INSERT INTO USERS(EMAIL, PASSWORD, CITY) VALUES (?,?,?)";
	private static final String SQL_UPDATE_USER="UPDATE USERS SET EMAIL = ?, PASSWORD = ?, CITY = ? WHERE ID_USER = ?";
	private static final String DELETE_USER="DELETE FROM USERS WHERE ID_USER=?";



	private DAOFactory daoFactory;

	@Override
	public void create(@NonNull User user) {

		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet autoGeneratedKeys = null;

		try {
			connection = this.daoFactory.getConnection();

			final String userEmail = user.getEmail();
			final String userHashedPassword = AuthenticationService.hashWithBCrypt(user.getPassword());
			final String userCity = user.getCity();

			// Insert query
			preparedStatement= DAOUtils.initPreparedStatement(connection, SQL_INSERT_USER, true, userEmail, userHashedPassword, userCity);
			int status = preparedStatement.executeUpdate();

			if (status == 0) {
				throw new DAOException("Failed to create user");
			}

			// Get autogenerated key for the users id
			autoGeneratedKeys=preparedStatement.getGeneratedKeys();
			if (autoGeneratedKeys.next()) {
				user.setDbId(autoGeneratedKeys.getObject(1).toString());
			} else {
				logger.log(Level.INFO, "Could not create the user, unable to generate proper Id");
			}

		} catch (SQLException e) {
			logger.log(Level.INFO, "Could not create the user", e);
		} finally {
			DAOUtils.silentClose(autoGeneratedKeys,preparedStatement,connection);
		}
	}

	@Override
	public void update(@NonNull User user) {
		Connection connection=null;
		PreparedStatement preparedStatement=null;

		//verifying the Id in input is not null
		if (user.getDbId() == null || user.getDbId().isEmpty()) {
			throw new DAOException("Cannot find the user to update");
		}

		try {
			connection = this.daoFactory.getConnection();
			preparedStatement=DAOUtils.initPreparedStatement(connection, SQL_UPDATE_USER,false,user.getEmail(),user.getPassword(), user.getCity(), user.getDbId());
			int status=preparedStatement.executeUpdate();

			if (status == 0) {
				throw new DAOException("Could not update the user");
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtils.silentClose(preparedStatement,connection);
		}
	}

	@Override
	public void delete(@NonNull User user) {
		Connection connection=null;
		PreparedStatement preparedStatement=null;

		// Checking if the user exists in the database
		if(user.getDbId() == null || user.getDbId().isEmpty()) {
			throw new DAOException("Could not delete the user, id not found");
		}

		try {
			connection=this.daoFactory.getConnection();
			preparedStatement= DAOUtils.initPreparedStatement(connection,DELETE_USER,false,user.getDbId());
			int status = preparedStatement.executeUpdate();

			if (status == 0) {
				throw new DAOException("Could not delete the user, query not executed");
			}
		} catch (SQLException e){
			throw new DAOException(e);
		} finally{
			DAOUtils.silentClose(preparedStatement,connection);
		}

	}

	@Override
	public User findBy(String id) {
		return selectBy(SQL_SELECT_BY_ID, id);
	}

	/**
	 * Select a {@link User} record from the database based upon its {@code email}
	 * @param email Email of the user to get from the database
	 * @return {@code null} if no {@link User} found, {@link User} record matching email otherwise
	 */
	public User findByEmail(String email) {
		return selectBy(SQL_SELECT_BY_EMAIL, email);
	}

	/**
	 * Generic function allowing to select a {@link User} from the database based upon different criteria
	 * @param sqlQuerySelector SQL Query string (with a single parameter to be set by a {@link PreparedStatement})
	 * @param value Value of the parameter to be set by a {@link PreparedStatement}
	 * @return {@code null} if no {@link User} found, {@link User} record matching criterion otherwise
	 */
	private User selectBy(String sqlQuerySelector, String value) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		User user = null;

		try {
			connection = this.daoFactory.getConnection();
			preparedStatement = DAOUtils.initPreparedStatement(connection, sqlQuerySelector, false, value);
			resultSet = preparedStatement.executeQuery();

			// If the result set is not empty
			if (resultSet.next()) {
				user = DAOUtils.mappingUser(resultSet);
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtils.silentClose(resultSet, preparedStatement, connection);
		}

		return user;
	}
}
