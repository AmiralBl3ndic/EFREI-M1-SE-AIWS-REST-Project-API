package efrei.m1.aiws.dao;

import efrei.m1.aiws.model.Book;
import efrei.m1.aiws.model.Comment;

import efrei.m1.aiws.model.Comment;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.NonNull;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.*;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

@NoArgsConstructor
@AllArgsConstructor
public class BookDAOImpl implements DAO<Book> {
	///region Class Properties
	///region Database columns names
	static final String DB_COL_BOOK_ID = "ID_BOOK";
	static final String DB_COL_BOOK_USER_ID = "ID_USERS";
	static final String DB_COL_BOOK_AUTHOR = "AUTHOR";
	static final String DB_COL_BOOK_TITLE = "TITLE";
	static final String DB_COL_BOOK_TYPE = "TYPE";
	static final String DB_COL_BOOK_DESCRIPTION = "DESCRIPTION";
	static final String DB_COL_BOOK_RELEASEDATE = "RELEASEDATE";
	static final String DB_COL_BOOK_EDITOR = "EDITOR";
	static final String DB_COL_BOOK_AGELIMIT = "AGELIMIT";

	///endregion

	///region SQL Queries
	private static final String SQL_SELECT_ALL = "SELECT * FROM BOOKS";
	private static final String SQL_SELECT_BY_ID_BOOK = "SELECT * FROM BOOKS WHERE ID_BOOK = ?";
	private static final String SQL_SELECT_BY_ID_USER = "SELECT * FROM BOOKS WHERE ID_USERS = ?";
	private static final String SQL_SELECT_BY_AUTHOR = "SELECT * FROM BOOKS WHERE AUTHOR = ?";
	private static final String SQL_SELECT_BY_TITLE = "SELECT * FROM BOOKS WHERE TITLE = ?";
	private static final String SQL_SELECT_BY_TYPE = "SELECT * FROM BOOKS WHERE TYPE = ?";
	private static final String SQL_SELECT_BY_RELEASEDATE = "SELECT * FROM BOOKS WHERE RELEASEDATE = ?";
	private static final String SQL_INSERT_BOOK = "INSERT INTO BOOKS(ID_USERS,AUTHOR,TITLE,TYPE,DESCRIPTION,RELEASEDATE,EDITOR) VALUES (?,?,?,?,?,?,?)";
	private static final String SQL_UPDATE_BOOK = "UPDATE BOOKS SET ID_BOOK = ?,ID_USERS = ?,AUTHOR = ?,TITLE = ?,TYPE = ?,DESCRIPTION = ?,RELEASEDATE = ?,EDITOR = ?,AGELIMIT = ? WHERE ID_BOOK = ?";
	private static final String SQL_DELETE_BOOK = "DELETE FROM BOOKS WHERE ID_BOOK = ?";
	///region SQL Queries on Comments
	private static final String SQL_SELECT_COMMENTS = "SELECT * FROM BOOKS v INNER JOIN BOOK_COMMENTS c on v.ID_BOOK= c.ID_BOOK_COMMENTED WHERE ID_BOOK=?";
	private static final String SQL_SELECT_COMMENT_BY_ID = "SELECT * FROM BOOK_COMMENTS WHERE ID_BOOK_COMMENTED = ? AND COMMENT_ID = ?";
	private static final String SQL_INSERT_COMMENT = "INSERT INTO BOOK_COMMENTS(ID_BOOK_COMMENTED, ID_COMMENTER_BOOK, COMMENT_CONTENT) VALUES (?, ?, ?)";
	private static final String SQL_DELETE_COMMENT = "DELETE FROM BOOK_COMMENTS WHERE COMMENT_ID = ?";
	private static final String SQL_UPDATE_COMMENT = "UPDATE BOOK_COMMENTS(ID_BOOK_COMMENTED = ?, ID_COMMENTER = ?, COMMENT_CONTENT = ?";
	///endregion
	
	///endregion

	private static final Logger logger = Logger.getLogger(BookDAOImpl.class.getName());
	///endregion

	private DAOFactory daoFactory;

	@Override
	public void create(@NonNull Book book) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet autoGeneratedKeys = null;

		try {
			final String userID = book.getUserId();
			final String author = book.getAuthor();
			final String title = book.getTitle();
			final String type = book.getType();
			final String description = book.getDescription();
			final String releaseDate = book.getReleaseDate();
			final String editor = book.getEditor();

			connection = this.daoFactory.getConnection();
			preparedStatement = DAOUtils.initPreparedStatement(connection, SQL_INSERT_BOOK, true, userID, author, title, type, description, releaseDate, editor);

			int state = preparedStatement.executeUpdate();

			if (state == 0) {
				throw new DAOException("error in the creation of the book");
			}

			autoGeneratedKeys = preparedStatement.getGeneratedKeys();
			if (autoGeneratedKeys.next()) {
				book.setBookId(autoGeneratedKeys.getObject(1).toString());
			} else {
				logger.log(Level.INFO, "error in the creation of the book : unable to generated proper ID");
			}
		} catch (SQLException e) {
			logger.log(Level.INFO, "error in the creation of the video game", e);
		} finally {
			DAOUtils.silentClose(autoGeneratedKeys, preparedStatement, connection);
		}
	}

	@Override
	public void update(@NonNull Book book) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;

		if (book.getBookId() == null) {
			throw new DAOException("impossible to find the book to update");
		}

		try {
			connection = this.daoFactory.getConnection();
			preparedStatement = DAOUtils.initPreparedStatement(connection, SQL_UPDATE_BOOK, true, book.getBookId(), book.getUserId(), book.getAuthor(), book.getTitle(), book.getType(), book.getDescription(), book.getReleaseDate(), book.getEditor(), book.getAgeLimit());
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtils.silentClose(preparedStatement, connection);
		}
	}

	@Override
	public void delete(@NonNull Book book) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;

		if (book.getBookId() == null) {
			throw new DAOException("impossible to find the book to delete");
		}

		try {
			connection = this.daoFactory.getConnection();
			preparedStatement = DAOUtils.initPreparedStatement(connection, SQL_DELETE_BOOK, false, book.getBookId());

			int state = preparedStatement.executeUpdate();

			if (state == 0) {
				throw new DAOException("impossible to delete the book");
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtils.silentClose(preparedStatement, connection);
		}
	}

	@Override
	public Book findBy(String id) {
		List<Book> candidates;
		candidates = this.selectBy(SQL_SELECT_BY_ID_BOOK, id);

		if (!candidates.isEmpty()) {
			return candidates.get(0);
		}

		return null;
	}

	private List<Book> selectBy(String sqlQuerySelector, String value) {
		List<Book> books = new ArrayList<>();
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;

		try {
			connection = this.daoFactory.getConnection();
			preparedStatement = DAOUtils.initPreparedStatement(connection, sqlQuerySelector, false, value);
			resultSet = preparedStatement.executeQuery();

			while (resultSet.next()) {
				books.add(DAOUtils.mappingBook(resultSet));
			}
		} catch (Exception e) {
			throw new DAOException(e);
		} finally {
			DAOUtils.silentClose(resultSet, preparedStatement, connection);
		}

		return books;
	}

	public List<Book> findAll() {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		List<Book> books = new ArrayList<>();

		try {
			connection = this.daoFactory.getConnection();
			preparedStatement = DAOUtils.initPreparedStatement(connection, SQL_SELECT_ALL, false);
			resultSet = preparedStatement.executeQuery();

			while(resultSet.next()) {
				books.add(DAOUtils.mappingBook(resultSet));
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtils.silentClose(resultSet, preparedStatement, connection);
		}
		return books;
	}

	public Book findByUserID(String id) {
		List<Book> candidates;
		candidates = this.selectBy(SQL_SELECT_BY_ID_USER, id);

		if (!candidates.isEmpty()) {
			return candidates.get(0);
		}

		return null;
	}

	public Book findByAuthor(String id) {
		List<Book> candidates;
		candidates = this.selectBy(SQL_SELECT_BY_AUTHOR, id);

		if (!candidates.isEmpty()) {
			return candidates.get(0);
		}

		return null;
	}

	public Book findByTittle(String id) {
		List<Book> candidates;
		candidates = this.selectBy(SQL_SELECT_BY_TITLE, id);

		if (!candidates.isEmpty()) {
			return candidates.get(0);
		}

		return null;
	}

	public Book findByType(String id) {
		List<Book> candidates;
		candidates = this.selectBy(SQL_SELECT_BY_TYPE, id);

		if (!candidates.isEmpty()) {
			return candidates.get(0);
		}

		return null;
	}

	public Book findByReleaseDate(String id) {
		List<Book> candidates;
		candidates = this.selectBy(SQL_SELECT_BY_RELEASEDATE, id);

		if (!candidates.isEmpty()) {
			return candidates.get(0);
		}

		return null;
	}

	public void createComment(Comment comment) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet autoGeneratedKeys = null;

		try {
			connection = this.daoFactory.getConnection();

			preparedStatement = DAOUtils.initPreparedStatement(connection, SQL_INSERT_COMMENT, true, comment.getResourceId(), comment.getCreatorId(), comment.getContent());
			int state = preparedStatement.executeUpdate();

			if (state == 0) {
				logger.log(Level.WARNING, "Error: cannot create book record");
				return;
			}

			autoGeneratedKeys = preparedStatement.getGeneratedKeys();
			if (autoGeneratedKeys.next()) {
				comment.setDbId(autoGeneratedKeys.getObject(1).toString());
			} else {
				logger.log(Level.INFO, "Error in the creation of the book comment : unable to generate proper Id");
			}
		} catch (SQLException e) {
			logger.log(Level.INFO, "Error in the creation of the book comment", e);
		} finally {
			DAOUtils.silentClose(autoGeneratedKeys, preparedStatement, connection);
		}
	}

	public void updateComment(Comment comment) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;

		if (comment.getDbId() == null) {
			logger.log(Level.WARNING, "Error: unable to find book comment to update!");
		}

		try {
			connection = this.daoFactory.getConnection();
			preparedStatement = DAOUtils.initPreparedStatement(connection, SQL_UPDATE_COMMENT, false, comment.getDbId(), comment.getContent(), comment.getCreatorId(), comment.getResourceId());

			int state = preparedStatement.executeUpdate();

			if(state == 0) {
				logger.log(Level.WARNING, "Error : unable to update book comment!");
			}

		} catch (SQLException e) {
			logger.log(Level.WARNING, "Error while update book comment record", e);
		} finally {
			DAOUtils.silentClose(preparedStatement, connection);
		}
	}


	/**
	 * Deletes the passed in {@link Comment} record from the database
	 * @param comment Comment to delete
	 * @return Whether the deletion succeeded
	 */
	public boolean deleteComment(Comment comment) {
		Connection connection = null;
		PreparedStatement preparedStatement = null;

		boolean deletionSucceeded = false;

		if (comment.getDbId() == null) {
			logger.log(Level.WARNING, "Unable to find book comment to delete");
			return false;
		}

		try {
			connection = this.daoFactory.getConnection();
			preparedStatement = DAOUtils.initPreparedStatement(connection, SQL_DELETE_COMMENT, false, comment.getDbId());

			int state = preparedStatement.executeUpdate();

			if (state == 0) {
				logger.log(Level.WARNING, "Unable to delete book comment record");
			} else {
				deletionSucceeded = true;
			}
		} catch (SQLException e) {
			logger.log(Level.WARNING, "Error while deleting book comment", e);
		} finally {
			DAOUtils.silentClose(preparedStatement, connection);
		}

		return deletionSucceeded;
	}


	/**
	 * Select a single comment of a specified book
	 * @param bookID ID of the {@link Book} to look comments for
	 * @param commentId Id of the {@link Comment} to look for
	 * @return {@link Comment} database record if the request succeeded, {@code null} in any other case
	 */
	public Comment selectCommentById(String bookID, String commentId) {
		Comment comment = null;
		Connection connection = null;
		PreparedStatement preparedStatement = null ;
		ResultSet resultSet = null;

		try {
			connection = this.daoFactory.getConnection();
			preparedStatement = DAOUtils.initPreparedStatement(connection, SQL_SELECT_COMMENT_BY_ID,false, bookID, commentId);
			resultSet=preparedStatement.executeQuery();

			if (resultSet.next()) {
				comment = DAOUtils.mappingCommentBooks(resultSet);
			}
		} catch (SQLException e) {
			logger.log(Level.WARNING, "Unable to get comment #" + commentId + " of book #" + bookID, e);
		} finally {
			DAOUtils.silentClose(resultSet, preparedStatement, connection);
		}

		return comment;
	}

	/**
	 * Function to list all the comments made on a given book
	 * @param idBook ID of the book database record to look the comments for
	 * @return List of all {@link Comment}s related to book record with id {@code book}
	 */
	public List<Comment> selectAllComments(String idBook) {
		List <Comment> comments = new ArrayList<>();
		Connection connection = null;
		PreparedStatement preparedStatement = null ;
		ResultSet resultSet = null;

		try {
			connection= this.daoFactory.getConnection();
			preparedStatement=DAOUtils.initPreparedStatement(connection,SQL_SELECT_COMMENTS,false,idBook);
			resultSet=preparedStatement.executeQuery();

			while(resultSet.next()) {
				comments.add(DAOUtils.mappingCommentBooks(resultSet));
			}
		} catch (SQLException e) {
			logger.log(Level.WARNING, "Unable to get comments of book)", e);
		}
		finally {
			DAOUtils.silentClose(resultSet, preparedStatement, connection);
		}

		return comments;
	}
}